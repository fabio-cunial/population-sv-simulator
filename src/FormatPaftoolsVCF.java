import java.io.*;


/**
 * Makes a VCF file generated by paftools amenable to downstream processing.
 *
 * Remark: a paftools VCF contains only indel SVs, so DUPs are hidden under INSs
 * and it is unclear how INVs are represented. See e.g.:
 * https://github.com/lh3/minimap2/blob/822ccd173358f11842b6dc54e17bbdcc2d9a0a9a/misc/paftools.js#L383
 */
public class FormatPaftoolsVCF {
    /**
     * VCF constants
     */
    private static final char COMMENT = '#';
    private static final String VCF_SEPARATOR = "\t";
    private static final String INFO_SEPARATOR = ";";
    private static final String SVLEN_STR = "SVLEN";
    private static final String END_STR = "END";
    private static final String SVTYPE_STR = "SVTYPE";
	private static final String DEL_STR = "DEL";
	private static final String INS_STR = "INS";
	private static final String FILTER = "PASS";
    
    
    public static void main(String[] args) throws IOException {
        final String INPUT_FILE = args[0];
        final String OUTPUT_FILE = args[1];
        final int MIN_SV_LENGTH = Integer.parseInt(args[2]);
        
        int p;
        int position, svLength;
		String str, info;
		BufferedReader br;
        BufferedWriter bw;
        String[] tokens;
        
		br = new BufferedReader(new FileReader(INPUT_FILE));
        bw = new BufferedWriter(new FileWriter(OUTPUT_FILE));
		str=br.readLine(); p=0;
		while (str!=null) {
            p++;
            if (p%1000==0) System.err.println("Processed "+p+" records");
			if (str.length()>=2 && str.charAt(0)==COMMENT && str.charAt(1)==COMMENT) {
                bw.write(str); bw.newLine();
				str=br.readLine();
				continue;
			}
            else if (str.charAt(0)==COMMENT) {
        		bw.write("##ALT=<ID=INS,Description=\"Insertion\">\n");
        		bw.write("##ALT=<ID=DEL,Description=\"Deletion\">\n");
        		bw.write("##FILTER=<ID=PASS,Description=\"All filters passed\">\n");
        		bw.write("##INFO=<ID=END,Number=1,Type=Integer,Description=\"End position of structural variation\">\n");
        		bw.write("##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variant\">\n");
        		bw.write("##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Length of structural variation\">\n");
                bw.write(str); bw.newLine();
				str=br.readLine();
				continue;
            }
			tokens=str.split("\t");
            position=Integer.parseInt(tokens[1]);
            if (tokens[3].length()==1 && tokens[4].length()>=MIN_SV_LENGTH+1) {
                svLength=tokens[4].length()-1;
                info=SVTYPE_STR+"="+INS_STR+INFO_SEPARATOR+SVLEN_STR+"="+svLength+INFO_SEPARATOR+END_STR+"="+(position+1)+INFO_SEPARATOR+tokens[7];
                bw.write(tokens[0]+VCF_SEPARATOR+tokens[1]+VCF_SEPARATOR+tokens[2]+VCF_SEPARATOR+tokens[3]+VCF_SEPARATOR+tokens[4]+VCF_SEPARATOR+tokens[5]+VCF_SEPARATOR+FILTER+VCF_SEPARATOR+info+VCF_SEPARATOR+tokens[8]+VCF_SEPARATOR+tokens[9]);
                bw.newLine();
            }
            else if (tokens[3].length()>=MIN_SV_LENGTH+1 && tokens[4].length()==1) {
                svLength=tokens[3].length()-1;
                info=SVTYPE_STR+"="+DEL_STR+INFO_SEPARATOR+SVLEN_STR+"=-"+svLength+INFO_SEPARATOR+END_STR+"="+(position+svLength)+INFO_SEPARATOR+tokens[7];
                bw.write(tokens[0]+VCF_SEPARATOR+tokens[1]+VCF_SEPARATOR+tokens[2]+VCF_SEPARATOR+tokens[3]+VCF_SEPARATOR+tokens[4]+VCF_SEPARATOR+tokens[5]+VCF_SEPARATOR+FILTER+VCF_SEPARATOR+info+VCF_SEPARATOR+tokens[8]+VCF_SEPARATOR+tokens[9]);
                bw.newLine();
            }
			str=br.readLine();
		}
		br.close(); bw.close();
        System.err.println("Done formatting file "+INPUT_FILE);
    }

}